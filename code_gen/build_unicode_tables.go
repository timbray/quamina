package main

import (
	"bufio"
	"cmp"
	"errors"
	"fmt"
	"io"
	"math"
	"net/http"
	"os"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"time"

	"quamina.net/go/quamina"
)

const (
	CaseFoldingURL     = "https://www.unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"
	CaseFoldingDB      = "case_folding.go"
	UnicodeDataURL     = "https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt"
	CharPropsDB        = "character_properties.go"
	ThreeMonthsInHours = 30 * 24 * 3
	CfPairsPerLine     = 6
	CpPairsPerLine     = 3
	cfReString         = `^([0-9a-fA-F]+); C; ([0-9a-fA-F]+);.*`
	cpReString         = `^([0-9a-fA-F]+);([^;]*);([^;]*);`
	CFFheader          = `package quamina

// Code generated by code_gen/build_unicode_tables - DO NOT EDIT.
// built from the "C" records in CaseFolding.txt in the Unicode character database
var caseFoldingPairs = map[rune]rune{`
	CPFheader = `package quamina

// Code generated by code_gen/build_unicode_tables - DO NOT EDIT.
// built from UnicodeData.txt in the Unicode character database
`
)

func main() {
	buildCasefoldingTable()
	buildCharPropsTable()
}

// only rebuild the tables if 3 months out of date
func needsRebuilding(filename string) bool {
	needToRebuild := false
	info, err := os.Stat(filename)
	if err != nil {
		needToRebuild = true
	} else {
		howOldInHours := time.Since(info.ModTime()).Hours()
		if howOldInHours > ThreeMonthsInHours {
			needToRebuild = true
		}
	}
	return needToRebuild
}

func buildCharPropsTable() {
	if !needsRebuilding(CharPropsDB) {
		fmt.Println(CharPropsDB + " doesn't need rebuilding.")
		return
	}

	resp, err := http.Get(UnicodeDataURL)
	if err != nil {
		fatal("Can't fetch UnicodeData.txt: " + err.Error())
	}
	defer func() { _ = resp.Body.Close() }()
	cpf, err := os.Create(CharPropsDB + ".tmp")
	if err != nil {
		fatal("Opening character_properties.go: " + err.Error())
	}
	_, err = cpf.Write([]byte(CPFheader))
	if err != nil {
		fatal("Write CPF header: " + err.Error())
	}
	doubles := make(map[string]quamina.RuneRange)
	lines := bufio.NewReader(resp.Body)
	re, err := regexp.Compile(cpReString)
	if err != nil {
		fatal("RE compile: " + err.Error())
	}

	// let's waste some memory by just making an array for every codepoint
	var props [runeMax]string

	// Cn means unassigned, which we assume everything is until it isn't
	for i := range props {
		props[i] = "Cn"
	}

	for {
		line, err := lines.ReadBytes('\n')
		if errors.Is(err, io.EOF) {
			break
		} else if err != nil {
			fatal("Error reading UnicodeData.txt: " + err.Error())
		}
		matches := re.FindSubmatch(line)
		if len(matches) != 4 {
			fatal("Weird line " + string(line))
		}
		r64, err := strconv.ParseInt(string(matches[1]), 16, 64)
		if err != nil {
			fatalf("failed to parse hex string in %s", line)
		}
		if r64 < 0 || r64 > math.MaxInt32 {
			fatalf("codepoint out of range: %d", r64)
		}
		property := string(matches[3])
		r := rune(r64)

		// if the line is a range, grab the next line too and fill in the range
		if strings.HasPrefix(string(matches[2]), "<") && strings.HasSuffix(string(matches[2]), "First>") {
			// it's a range, write a pair to cover that
			next, _ := lines.ReadBytes('\n')
			nextMatches := re.FindSubmatch(next)
			nextR64, _ := strconv.ParseInt(string(nextMatches[1]), 16, 64)
			if nextR64 < 0 || nextR64 > math.MaxInt32 {
				fatalf("codepoint out of range: %d", nextR64)
			}
			nextRune := rune(nextR64)
			for i := r; i <= nextRune; i++ {
				props[i] = property
			}
		} else {
			props[r] = property
		}
	}

	// turn the ranges into pairs
	currentProp := "Cc"
	var currentStartsAt rune = 0
	for i := range props {
		char := rune(i)
		if props[char] != currentProp {
			recordPair(currentStartsAt, char-1, currentProp, doubles)
			currentStartsAt = rune(i)
			currentProp = props[i]
		}
	}

	// now record the single-letter properties
	singles := make(map[string]quamina.RuneRange)
	for prop, pairs := range doubles {
		single := prop[:1]
		for _, pair := range pairs {
			recordPair(pair.Lo, pair.Hi, single, singles)
		}
	}

	for single, pairs := range singles {
		doubles[single] = pairs
	}

	// now generate the output
	fmt.Fprintf(cpf, "\nvar characterProperties = map[string]RuneRange{\n")
	sortedProps := []string{}
	for property := range doubles {
		sortedProps = append(sortedProps, property)
	}

	// arrange the maps in alphabetical order for aesthatic reasons
	slices.Sort(sortedProps)

	for _, prop := range sortedProps {
		fmt.Fprintf(cpf, "  \"%s\": {", prop)
		pairs := doubles[prop]

		// likewise the pairs
		slices.SortFunc(pairs, func(a, b quamina.RunePair) int { return cmp.Compare(a.Lo, b.Lo) })

		onLine := CpPairsPerLine
		for _, pair := range pairs {
			if onLine == CpPairsPerLine {
				_, _ = cpf.WriteString("\n    ")
				onLine = 0
			}
			fmt.Fprintf(cpf, "{0x%04x, 0x%04x}, ", pair.Lo, pair.Hi)
			onLine++
		}
		fmt.Fprintln(cpf, "\n  },")
	}
	fmt.Fprintln(cpf, "}")

	// now write the negated properties
	fmt.Fprintf(cpf, "\nvar negatedProperties = map[string]RuneRange{\n")

	invertedPairs := make(map[string]quamina.RuneRange)
	for _, prop := range sortedProps {
		invertedPairs[prop] = quamina.InvertRuneRange(doubles[prop])
	}
	for _, prop := range sortedProps {
		fmt.Fprintf(cpf, "  \"%s\": {", prop)
		pairs := invertedPairs[prop]

		slices.SortFunc(pairs, func(a, b quamina.RunePair) int { return cmp.Compare(a.Lo, b.Lo) })

		onLine := CpPairsPerLine
		for _, pair := range pairs {
			if onLine == CpPairsPerLine {
				_, _ = cpf.WriteString("\n    ")
				onLine = 0
			}
			fmt.Fprintf(cpf, "{0x%04x, 0x%04x}, ", pair.Lo, pair.Hi)
			onLine++
		}
		fmt.Fprintln(cpf, "\n  },")
	}
	fmt.Fprintln(cpf, "}")
	fmt.Printf("Rebuilt character_properties.go\n")
	pairs := 0
	for _, prop := range sortedProps {
		fmt.Printf("%s: %d/%d\n", prop, len(doubles[prop]), len(invertedPairs[prop]))
		pairs += len(doubles[prop])
		pairs += len(invertedPairs[prop])
	}
	fmt.Printf(" Total: %d\n", pairs)
	_ = cpf.Close()
	err = os.Rename(CharPropsDB+".tmp", CharPropsDB)
	if err != nil {
		fatalf("Error switching in %s: ", err.Error())
	}
}

const runeMax = 0x10ffff

func recordPair(start rune, end rune, props string, ranges map[string]quamina.RuneRange) {
	r, ok := ranges[props]
	if !ok {
		r = quamina.RuneRange{quamina.RunePair{Lo: start, Hi: end}}
	} else {
		r = append(r, quamina.RunePair{Lo: start, Hi: end})
	}
	ranges[props] = r
}

func buildCasefoldingTable() {
	if !needsRebuilding(CaseFoldingDB) {
		fmt.Println(CaseFoldingDB + " doesn't need rebuilding.")
		return
	}
	resp, err := http.Get(CaseFoldingURL)
	if err != nil {
		fatal("Can't fetch CaseFolding.txt: " + err.Error())
	}
	defer func() { _ = resp.Body.Close() }()
	cff, err := os.Create(CaseFoldingDB + ".tmp")
	if err != nil {
		fatal("Opening CaseFolding.txt: " + err.Error())
	}
	_, err = cff.Write([]byte(CFFheader))
	if err != nil {
		fatal("Write CFF header: " + err.Error())
	}
	lines := bufio.NewReader(resp.Body)
	re, err := regexp.Compile(cfReString)
	if err != nil {
		fatal("RE compile: " + err.Error())
	}
	mappings := make(map[string]string)

	for {
		line, err := lines.ReadBytes('\n')
		if errors.Is(err, io.EOF) {
			break
		} else if err != nil {
			fatal("Error reading CaseFolding.txt: " + err.Error())
		}
		if line[0] == '#' || len(line) == 1 {
			continue
		}
		matches := re.FindSubmatch(line)
		if len(matches) != 3 {
			continue
		}
		_, err = strconv.ParseInt(string(matches[1]), 16, 64)
		if err != nil {
			fatalf("failed to parse hex string in %s", line)
		}
		_, err = strconv.ParseInt(string(matches[2]), 16, 64)
		if err != nil {
			fatalf("failed to parse hex string in %s", line)
		}
		_, ok := mappings[string(matches[1])]
		if !ok {
			mappings[string(matches[1])] = string(matches[2])
		}
		_, ok = mappings[string(matches[2])]
		if !ok {
			mappings[string(matches[2])] = string(matches[1])
		}
	}
	onLine := CfPairsPerLine
	for lhs, rhs := range mappings {
		if onLine == CfPairsPerLine {
			_, err = cff.WriteString("\n\t")
			if err != nil {
				fatal("failed to write line-end: " + err.Error())
			}
			onLine = 0
		}
		_, err = fmt.Fprintf(cff, "0x%s: 0x%s, ", lhs, rhs)
		if err != nil {
			fatal("failed to write pair: " + err.Error())
		}
		onLine++
	}
	_, _ = cff.Write([]byte("\n}\n"))
	_ = cff.Close()
	fmt.Printf("Rebuilt case_folding.go with %d codepoint pairs.\n", len(mappings))
	err = os.Rename(CaseFoldingDB+".tmp", CaseFoldingDB)
	if err != nil {
		fatalf("Error switching in %s: ", err.Error())
	}
}

func fatal(message string) {
	_, _ = fmt.Fprintln(os.Stderr, message)
	os.Exit(1)
}
func fatalf(format string, args ...any) {
	_, _ = fmt.Fprintf(os.Stderr, format, args...)
	os.Exit(1)
}
