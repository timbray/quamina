package main

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"time"
)

const (
	CaseFoldingURL     = "https://www.unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"
	CaseFoldingDB      = "case_folding.go"
	ThreeMonthsInHours = 30 * 24 * 3
	PairsPerLine       = 6
	reString           = `^([0-9a-fA-F]+); C; ([0-9a-fA-F]+);.*`
	CFFheader          = `package quamina
	
// Code generated by code_gen/code_gen - DO NOT EDIT.
// built from the "C" records in CaseFolding.txt in the Unicode character database
var caseFoldingPairs = map[rune]rune{`
)

func main() {
	// only rebuild the database if it's 3 months out of date
	needToRebuild := false
	info, err := os.Stat(CaseFoldingDB)
	if err != nil {
		needToRebuild = true
	} else {
		howOldInHours := time.Since(info.ModTime()).Hours()
		if howOldInHours > ThreeMonthsInHours {
			needToRebuild = true
		}
	}
	if !needToRebuild {
		fmt.Println("Skipping codegen.")
		return
	}
	resp, err := http.Get(CaseFoldingURL)
	if err != nil {
		fatal("Can't fetch CaseFolding.txt: " + err.Error())
	}
	defer func() { _ = resp.Body.Close() }()
	cff, err := os.Create(CaseFoldingDB + ".tmp")
	if err != nil {
		fatal("Opening CaseFolding.txt: " + err.Error())
	}
	_, err = cff.Write([]byte(CFFheader))
	if err != nil {
		fatal("Write CFF header: " + err.Error())
	}
	lines := bufio.NewReader(resp.Body)
	re, err := regexp.Compile(reString)
	if err != nil {
		fatal("RE compile: " + err.Error())
	}
	mappings := make(map[string]string)

	for {
		line, err := lines.ReadBytes('\n')
		if errors.Is(err, io.EOF) {
			break
		} else if err != nil {
			fatal("Error reading CaseFolding.txt: " + err.Error())
		}
		if line[0] == '#' || len(line) == 1 {
			continue
		}
		matches := re.FindSubmatch(line)
		if len(matches) != 3 {
			continue
		}
		_, err = strconv.ParseInt(string(matches[1]), 16, 64)
		if err != nil {
			fatalF("failed to parse hex string in %s", line)
		}
		_, err = strconv.ParseInt(string(matches[2]), 16, 64)
		if err != nil {
			fatalF("failed to parse hex string in %s", line)
		}
		_, ok := mappings[string(matches[1])]
		if !ok {
			mappings[string(matches[1])] = string(matches[2])
		}
		_, ok = mappings[string(matches[2])]
		if !ok {
			mappings[string(matches[2])] = string(matches[1])
		}
	}
	onLine := PairsPerLine
	for lhs, rhs := range mappings {
		if onLine == PairsPerLine {
			_, err = cff.WriteString("\n\t")
			if err != nil {
				fatal("failed to write line-end: " + err.Error())
			}
			onLine = 0
		}
		_, err = fmt.Fprintf(cff, "0x%s: 0x%s, ", lhs, rhs)
		if err != nil {
			fatal("failed to write pair: " + err.Error())
		}
		onLine++
	}
	_, _ = cff.Write([]byte("\n}\n"))
	_ = cff.Close()
	fmt.Printf("Rebuilt case_folding.go with %d codepoint pairs.\n", len(mappings))
	err = os.Rename(CaseFoldingDB+".tmp", CaseFoldingDB)
	if err != nil {
		fatalF("Error switching in %s: ", err.Error())
	}
}

func fatal(message string) {
	_, _ = fmt.Fprintln(os.Stderr, message)
	os.Exit(1)
}
func fatalF(format string, args ...any) {
	_, _ = fmt.Fprintf(os.Stderr, format, args...)
	os.Exit(1)
}
